{
  "author": "",
  "category": "Advanced",
  "extensionNamespace": "",
  "fullName": "Atlas map shader material",
  "helpPath": "https://github.com/GuestGD",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8Zz4NCgk8cGF0aCBkPSJNMjMsN0g5Yy0xLjcsMC0zLDEuMy0zLDN2MTAuN2w5LjUtNS41YzAuMy0wLjIsMC44LTAuMiwxLjEsMC4xbDMuNSwyLjZsNS45LTMuNlYxMEMyNiw4LjMsMjQuNyw3LDIzLDd6IE0xMiwxNA0KCQljLTEuMSwwLTItMC45LTItMnMwLjktMiwyLTJzMiwwLjksMiwyUzEzLjEsMTQsMTIsMTR6Ii8+DQoJPHBhdGggZD0iTTE5LjQsMTkuOGwtMy41LTIuNmwtOS44LDUuN0M2LjUsMjQuMSw3LjcsMjUsOSwyNWgxNGMxLjcsMCwzLTEuMywzLTN2LTUuNGwtNS41LDMuM0MyMC4yLDIwLjEsMTkuNywyMCwxOS40LDE5Ljh6Ii8+DQoJPHBhdGggZD0iTTEzLjcsNS43TDE2LDMuNGwyLjMsMi4zQzE4LjUsNS45LDE4LjcsNiwxOSw2czAuNS0wLjEsMC43LTAuM2MwLjQtMC40LDAuNC0xLDAtMS40bC0zLTNjLTAuNC0wLjQtMS0wLjQtMS40LDBsLTMsMw0KCQljLTAuNCwwLjQtMC40LDEsMCwxLjRTMTMuMyw2LjEsMTMuNyw1Ljd6Ii8+DQoJPHBhdGggZD0iTTE4LjMsMjYuM0wxNiwyOC42bC0yLjMtMi4zYy0wLjQtMC40LTEtMC40LTEuNCwwcy0wLjQsMSwwLDEuNGwzLDNjMC4yLDAuMiwwLjUsMC4zLDAuNywwLjNzMC41LTAuMSwwLjctMC4zbDMtMw0KCQljMC40LTAuNCwwLjQtMSwwLTEuNFMxOC43LDI1LjksMTguMywyNi4zeiIvPg0KCTxwYXRoIGQ9Ik00LjcsMTIuM2MtMC40LTAuNC0xLTAuNC0xLjQsMGwtMywzYy0wLjQsMC40LTAuNCwxLDAsMS40bDMsM0MzLjUsMTkuOSwzLjcsMjAsNCwyMHMwLjUtMC4xLDAuNy0wLjNjMC40LTAuNCwwLjQtMSwwLTEuNA0KCQlMMi40LDE2bDIuMy0yLjNDNS4xLDEzLjMsNS4xLDEyLjcsNC43LDEyLjN6Ii8+DQoJPHBhdGggZD0iTTMxLjcsMTUuM2wtMy0zYy0wLjQtMC40LTEtMC40LTEuNCwwcy0wLjQsMSwwLDEuNGwyLjMsMi4zbC0yLjMsMi4zYy0wLjQsMC40LTAuNCwxLDAsMS40YzAuMiwwLjIsMC41LDAuMywwLjcsMC4zDQoJCXMwLjUtMC4xLDAuNy0wLjNsMy0zQzMyLjEsMTYuMywzMi4xLDE1LjcsMzEuNywxNS4zeiIvPg0KPC9nPg0KPC9zdmc+DQo=",
  "name": "AtlasMapMaterial",
  "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/Glyphster Pack/Master/SVG/Virtual Reality/3ae09a113ab6c03a868a22a988008d3663b3cc1038cd9cd65529955fb1cafb5f_Virtual Reality_panorama_picture_image_view.svg",
  "shortDescription": "Atlas map shader material",
  "version": "0.0.1",
  "description": "Atlas map shader material",
  "tags": [
    "shader material instanced mesh perfomance optimization atlas map"
  ],
  "authorIds": [
    "W0yoMQqOeiULIwY1i1Qd8tprOyD2"
  ],
  "dependencies": [],
  "globalVariables": [],
  "sceneVariables": [],
  "eventsFunctions": [
    {
      "description": "Create atlas standard material ",
      "fullName": "Create atlas standard material ",
      "functionType": "Action",
      "name": "CreateAtlasStandardMaterial",
      "sentence": "Create atlas standard material. Material name: _PARAM1_ atlasRows: _PARAM2_ atlasColumns: _PARAM3_ paddingPixels: _PARAM4_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "const materialName = eventsFunctionContext.getArgument(\"materialName\");",
            "const atlasRows = eventsFunctionContext.getArgument(\"atlasRows\");",
            "const atlasCols = eventsFunctionContext.getArgument(\"atlasColumns\");",
            "const paddingPixels = eventsFunctionContext.getArgument(\"paddingPixels\");",
            "if (!scene || !materialName) return;",
            "if (!scene.userData.materials) {",
            "    scene.userData.materials = {};",
            "}",
            "const slots = new Uint8Array(46);",
            "// Create the ShaderMaterial",
            "const material = new THREE.MeshStandardMaterial({",
            "    onBeforeCompile: (shader) => {",
            "        material.userData.shader = shader;      ",
            "        shader.uniforms.atlasRows = { value: atlasRows };",
            "        shader.uniforms.atlasCols = { value: atlasCols };",
            "        shader.uniforms.paddingPixels = { value: paddingPixels };",
            "        shader.uniforms.mapSlots = { value: slots };",
            "        //Adding new uniforms and atlas map function",
            "        shader.fragmentShader = shader.fragmentShader.replace(",
            "            `#define STANDARD`,",
            "            `\\n\\#define STANDARD\\n\\t",
            "             uniform float atlasRows;\\n\\t",
            "             uniform float atlasCols;\\n\\t",
            "             uniform float mapSlots[46];\\n\\t",
            "             uniform float paddingPixels;\\n\\t",
            "",
            "            \\n\\t // Function to calculate UV coordinates for a specific map in the atlas with padding",
            "            vec2 getAtlasUV(vec2 uv, float row, float col, sampler2D map) {",
            "                float tileWidth = 1.0 / atlasCols;",
            "                float tileHeight = 1.0 / atlasRows;",
            "",
            "                // Convert padding from pixels to UV space",
            "                float paddingX = paddingPixels / float(textureSize(map, 0).x); // Cast to float",
            "                float paddingY = paddingPixels / float(textureSize(map, 0).y); // Cast to float",
            "",
            "                // Calculate the effective UV range after applying padding",
            "                float effectiveWidth = tileWidth - 2.0 * paddingX;",
            "                float effectiveHeight = tileHeight - 2.0 * paddingY;",
            "",
            "                // Adjust UVs to account for padding and scale within the effective range",
            "                float u = (col * tileWidth) + paddingX + (uv.x * effectiveWidth);",
            "                float v = (row * tileHeight) + paddingY + (uv.y * effectiveHeight);",
            "",
            "                return vec2(u, v);",
            "            }\\n\\t`",
            "        )",
            "        //Setting new map UV via Atlas map function",
            "        shader.fragmentShader = shader.fragmentShader.replace(",
            "            `#include <map_fragment>`,",
            "            `",
            "            #ifdef USE_MAP",
            "                vec2 vMapUv = getAtlasUV(vMapUv, mapSlots[0], mapSlots[1], map);",
            "            #endif",
            "            #ifdef USE_ALPHAMAP",
            "                vec2 vAlphaMapUv = getAtlasUV(vAlphaMapUv, mapSlots[2], mapSlots[3], alphaMap);",
            "            #endif",
            "            #ifdef USE_LIGHTMAP",
            "                vec2 vLightMapUv = getAtlasUV(vLightMapUv, mapSlots[4], mapSlots[5], lightMap);",
            "            #endif",
            "            #ifdef USE_AOMAP",
            "                vec2 vAoMapUv = getAtlasUV(vAoMapUv, mapSlots[6], mapSlots[7], aoMap);",
            "            #endif",
            "            #ifdef USE_BUMPMAP",
            "                vec2 vBumpMapUv = getAtlasUV(vBumpMapUv, mapSlots[8], mapSlots[9], bumpMap);",
            "            #endif",
            "            #ifdef USE_NORMALMAP",
            "                vec2 vNormalMapUv = getAtlasUV(vNormalMapUv, mapSlots[10], mapSlots[11], normalMap);",
            "            #endif",
            "            #ifdef USE_DISPLACEMENTMAP",
            "                vec2 vDisplacementMapUv = getAtlasUV(vDisplacementMapUv, mapSlots[12], mapSlots[13], displacementMap);",
            "            #endif",
            "            #ifdef USE_EMISSIVEMAP",
            "                vec2 vEmissiveMapUv = getAtlasUV(vEmissiveMapUv, mapSlots[14], mapSlots[15], emissiveMap);",
            "            #endif",
            "            #ifdef USE_METALNESSMAP",
            "                vec2 vMetalnessMapUv = getAtlasUV(vMetalnessMapUv, mapSlots[16], mapSlots[17], metalnessMap);",
            "            #endif",
            "            #ifdef USE_ROUGHNESSMAP",
            "                vec2 vRoughnessMapUv = getAtlasUV(vRoughnessMapUv, mapSlots[18], mapSlots[19], roughnessMap);",
            "            #endif",
            "            #ifdef USE_ANISOTROPYMAP",
            "                vec2 vAnisotropyMapUv = getAtlasUV(vAnisotropyMapUv, mapSlots[20], mapSlots[21], anisotropyMap);",
            "            #endif",
            "            #ifdef USE_CLEARCOATMAP",
            "                vec2 vClearcoatMapUv = getAtlasUV(vClearcoatMapUv, mapSlots[22], mapSlots[23], clearcoatMap);",
            "            #endif",
            "            #ifdef USE_CLEARCOAT_NORMALMAP",
            "                vec2 vClearcoatNormalMapUv = getAtlasUV(vClearcoatNormalMapUv, mapSlots[24], mapSlots[25], clearcoatNormalMap);",
            "            #endif",
            "            #ifdef USE_CLEARCOAT_ROUGHNESSMAP",
            "                vec2 vClearcoatRoughnessMapUv = getAtlasUV(vClearcoatRoughnessMapUv, mapSlots[26], mapSlots[27], clearcoatRoughnessMap);",
            "            #endif",
            "            #ifdef USE_IRIDESCENCEMAP",
            "                vec2 vIridescenceMapUv = getAtlasUV(vIridescenceMapUv, mapSlots[28], mapSlots[29], iridescenceMap);",
            "            #endif",
            "            #ifdef USE_IRIDESCENCE_THICKNESSMAP",
            "                vec2 vIridescenceThicknessMapUv = getAtlasUV(vIridescenceThicknessMapUv, mapSlots[30], mapSlots[31], iridescenceThicknessMap);",
            "            #endif",
            "            #ifdef USE_SHEEN_COLORMAP",
            "                vec2 vSheenColorMapUv = getAtlasUV(vSheenColorMapUv, mapSlots[32], mapSlots[33], sheenColorMap);",
            "            #endif",
            "            #ifdef USE_SHEEN_ROUGHNESSMAP",
            "                vec2 vSheenRoughnessMapUv = getAtlasUV(vSheenRoughnessMapUv, mapSlots[34], mapSlots[35], sheenRoughnessMap);",
            "            #endif",
            "            #ifdef USE_SPECULARMAP",
            "                vec2 vSpecularMapUv = getAtlasUV(vSpecularMapUv, mapSlots[36], mapSlots[37], specularMap);",
            "            #endif",
            "            #ifdef USE_SPECULAR_COLORMAP",
            "                vec2 vSpecularColorMapUv = getAtlasUV(vSpecularColorMapUv, mapSlots[38], mapSlots[39], specularColorMap);",
            "            #endif",
            "            #ifdef USE_SPECULAR_INTENSITYMAP",
            "                vec2 vSpecularIntensityMapUv = getAtlasUV(vSpecularIntensityMapUv, mapSlots[40], mapSlots[41], specularIntensityMap);",
            "            #endif",
            "            #ifdef USE_TRANSMISSIONMAP",
            "                vec2 vTransmissionMapUv = getAtlasUV(vTransmissionMapUv, mapSlots[42], mapSlots[43], transmissionMap);",
            "            #endif",
            "            #ifdef USE_THICKNESSMAP",
            "                vec2 vThicknessMapUv = getAtlasUV(vThicknessMapUv, mapSlots[44], mapSlots[45], thicknessMap);",
            "            #endif",
            "             \\n\\t #include <map_fragment>",
            "             \\n\\t",
            "            `",
            "        )",
            "    }",
            "});",
            "if (material) {",
            "    material.name = materialName;",
            "    scene.userData.materials[materialName] = material;",
            "}"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "materialName",
          "name": "materialName",
          "type": "string"
        },
        {
          "description": "atlasRows",
          "name": "atlasRows",
          "type": "expression"
        },
        {
          "description": "atlasColumns",
          "name": "atlasColumns",
          "type": "expression"
        },
        {
          "description": "paddingPixels",
          "name": "paddingPixels",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Add atlas material",
      "fullName": "Add atlas material",
      "functionType": "Action",
      "name": "AddAtlasShaderMaterial",
      "sentence": "Add atlas material for: _PARAM1_ Material name: _PARAM2_ roughnessIntensity: _PARAM3_ metalnessIntensity: _PARAM4_ aoIntensity: _PARAM5_ envMapIntensity: _PARAM6_ reflectivity: _PARAM7_ useSRGB: _PARAM8_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "const targetName = eventsFunctionContext.getArgument(\"targetName\");",
            "const materialName = eventsFunctionContext.getArgument(\"materialName\");",
            "",
            "if (!scene || !targetName || !materialName) {",
            "    return;",
            "}",
            "if (!scene.userData.materials) {",
            "    scene.userData.materials = {};",
            "}",
            "const material = scene.userData.materials[materialName];",
            "if (!material) {",
            "    return;",
            "}",
            "scene.traverse(node => {",
            "    if (node.isMesh && node.material.isMaterial && node.name === targetName) {",
            "        node.material = material;",
            "        node.material.needsUpdate = true;",
            "    }",
            "});"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "targetName",
          "name": "targetName",
          "type": "string"
        },
        {
          "description": "materialName",
          "name": "materialName",
          "type": "string"
        },
        {
          "description": "roughnessIntensity",
          "name": "roughnessIntensity",
          "type": "expression"
        },
        {
          "description": "metalnessIntensity",
          "name": "metalnessIntensity",
          "type": "expression"
        },
        {
          "description": "aoIntensity",
          "name": "aoIntensity",
          "type": "expression"
        },
        {
          "description": "envMapIntensity",
          "name": "envMapIntensity",
          "type": "expression"
        },
        {
          "description": "reflectivity",
          "name": "reflectivity",
          "type": "expression"
        },
        {
          "description": "useSRGB",
          "name": "useSRGB",
          "type": "trueorfalse"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Add map to atlas material",
      "fullName": "Add map to atlas material",
      "functionType": "Action",
      "name": "AddMap",
      "sentence": "Add map to atlas material for: _PARAM1_ Material name: _PARAM2_ Picked map: _PARAM3_ Map name: _PARAM4_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "const targetName = eventsFunctionContext.getArgument(\"targetName\");",
            "const materialName = eventsFunctionContext.getArgument(\"materialName\");",
            "const pickMap = eventsFunctionContext.getArgument(\"pickMap\");",
            "const mapName = eventsFunctionContext.getArgument(\"mapName\");",
            "",
            "if (!scene || !targetName || !materialName || !pickMap || !mapName) {",
            "    return;",
            "}",
            "if (!scene.userData.materials) {",
            "    scene.userData.materials = {};",
            "}",
            "const material = scene.userData.materials[materialName];",
            "if (!material) {",
            "    return;",
            "}",
            "const map = scene.userData.textures[mapName];",
            "if (!map) return;",
            "scene.traverse(node => {",
            "    if (node.isMesh && node.material.isMaterial && node.name === targetName) {",
            "        switch (pickMap) {",
            "            case 'map':",
            "                material.map = map;",
            "                break;",
            "            case 'alphaMap':",
            "                material.alphaMap = map;",
            "                break;",
            "            case 'lightMap':",
            "                material.lightMap = map;",
            "                break;",
            "            case 'aoMap':",
            "                material.aoMap = map;",
            "                break;",
            "            case 'bumpMap':",
            "                material.bumpMap = map;",
            "                break;",
            "            case 'normalMap':",
            "                material.normalMap = map;",
            "                break;",
            "            case 'displacementMap':",
            "                material.displacementMap = map;",
            "                break;",
            "            case 'emissiveMap':",
            "                material.emissiveMap = map;",
            "                break;",
            "            case 'metalnessMap':",
            "                material.metalnessMap = map;",
            "                break;",
            "            case 'roughnessMap':",
            "                material.roughnessMap = map;",
            "                break;",
            "            case 'anisotropyMap':",
            "                material.anisotropyMap = map;",
            "                break;",
            "            case 'clearcoatMap':",
            "                material.clearcoatMap = map;",
            "                break;",
            "            case 'clearcoatNormalMap':",
            "                material.clearcoatNormalMap = map;",
            "                break;",
            "            case 'clearcoatRoughnessMap':",
            "                material.clearcoatRoughnessMap = map;",
            "                break;",
            "            case 'iridescenceMap':",
            "                material.iridescenceMap = map;",
            "                break;",
            "            case 'iridescenceThicknessMap':",
            "                material.iridescenceThicknessMap = map;",
            "                break;",
            "            case 'sheenColorMap':",
            "                material.sheenColorMap = map;",
            "                break;",
            "            case 'sheenRoughnessMap':",
            "                material.sheenRoughnessMap = map;",
            "                break;",
            "            case 'specularMap':",
            "                material.specularMap = map;",
            "                break;",
            "            case 'specularColorMap':",
            "                material.specularColorMap = map;",
            "                break;",
            "            case 'specularIntensityMap':",
            "                material.specularIntensityMap = map;",
            "                break;",
            "            case 'transmissionMap':",
            "                material.transmissionMap = map;",
            "                break;",
            "            case 'thicknessMap':",
            "                material.thicknessMap = map;",
            "                break;",
            "            default:",
            "                material.map = map;",
            "        };",
            "",
            "        node.material.needsUpdate = true;",
            "    }",
            "});"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "targetName",
          "name": "targetName",
          "type": "string"
        },
        {
          "description": "materialName",
          "name": "materialName",
          "type": "string"
        },
        {
          "description": "Pick pbr map",
          "name": "pickMap",
          "supplementaryInformation": "[\"map\",\"alphaMap\",\"lightMap\",\"aoMap\",\"bumpMap\",\"normalMap\",\"displacementMap\",\"emissiveMap\",\"metalnessMap\",\"roughnessMap\",\"anisotropyMap\",\"clearcoatMap\",\"clearcoatNormalMap\",\"clearcoatRoughnessMap\",\"iridescenceMap\",\"iridescenceThicknessMap\",\"sheenColorMap\",\"sheenRoughnessMap\",\"specularMap\",\"specularColorMap\",\"specularIntensityMap\",\"transmissionMap\",\"thicknessMap\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Loaded map name",
          "name": "mapName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Add envMap",
      "fullName": "Add envMap",
      "functionType": "Action",
      "group": "Maps",
      "name": "AddEnvMap",
      "sentence": "Add envMap. Material name _PARAM1_ envMap name: _PARAM2_ intensity: _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const scene = runtimeScene.getLayer().getRenderer().getThreeScene();",
            "if (!scene.userData.textures) {",
            "    scene.userData.textures = {};",
            "}",
            "const materialName = eventsFunctionContext.getArgument(\"materialName\")",
            "const material = scene.userData.materials[materialName];",
            "const mapName = eventsFunctionContext.getArgument(\"mapName\") || \"envMap\";",
            "const intensity = eventsFunctionContext.getArgument(\"intensity\");",
            "if (!material || !mapName || !intensity) return;",
            "",
            "const prefilteredCubemap = scene.userData.textures[mapName];",
            "",
            "if (prefilteredCubemap || prefilteredCubemap instanceof THREE.CubeTexture()) {",
            "    material.envMap = prefilteredCubemap;",
            "    material.envMapIntensity = intensity;",
            "    material.needsUpdate = true;",
            "}",
            "",
            "",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        },
        {
          "disabled": true,
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const scene = runtimeScene.getLayer().getRenderer().getThreeScene();",
            "if (!scene.userData.textures) {",
            "    scene.userData.textures = {};",
            "}",
            "",
            "const mapName = eventsFunctionContext.getArgument(\"mapName\") || \"envMap\";",
            "const Intensity = eventsFunctionContext.getArgument(\"intensity\");",
            "const envMapName = eventsFunctionContext.getArgument(\"envMapName\");",
            "const materialName = eventsFunctionContext.getArgument(\"materialName\");",
            "const material = scene.userData.materials[materialName];",
            "if (!material) {",
            "    return;",
            "}",
            "const ThreeRenderer = runtimeScene.getGame().getRenderer().getThreeRenderer();",
            "if (!ThreeRenderer) {",
            "    return;",
            "}",
            "const Right = \"px.jpg\";",
            "const Left = \"nx.jpg\";",
            "const Top = \"py.jpg\";",
            "const Bottom = \"ny.jpg\";",
            "const Front = \"pz.jpg\";",
            "const Back = \"nz.jpg\";",
            "const FlipY = false;",
            "",
            "function loadTexture(path) {",
            "    if (!scene.userData.textures[path]) {",
            "        const resource = runtimeScene.getGame().getImageManager().getPIXITexture(path).baseTexture.resource;",
            "        scene.userData.textures[path] = resource.source;",
            "    }",
            "    return scene.userData.textures[path];",
            "}",
            "",
            "const FrontResource = loadTexture(Front);",
            "const BackResource = loadTexture(Back);",
            "const LeftResource = loadTexture(Left);",
            "const RightResource = loadTexture(Right);",
            "const TopResource = loadTexture(Top);",
            "const BottomResource = loadTexture(Bottom);",
            "",
            "if (FrontResource && BackResource && LeftResource && RightResource && TopResource && BottomResource) {",
            "    const CubeTexture = new THREE.CubeTexture([LeftResource, RightResource, FrontResource, BackResource, TopResource, BottomResource]);",
            "    CubeTexture.colorSpace = THREE.SRGBColorSpace;",
            "    CubeTexture.needsUpdate = true;",
            "",
            "    const pmremGenerator = new THREE.PMREMGenerator(ThreeRenderer);",
            "    pmremGenerator.compileCubemapShader();",
            "",
            "    const prefilteredCubemap = pmremGenerator.fromCubemap(CubeTexture).texture;",
            "    pmremGenerator.dispose();",
            "    scene.userData.textures[mapName] = prefilteredCubemap;",
            "    console.log(\"ENVMAP WAS LOADED\")",
            "    material.envMap = prefilteredCubemap;",
            "    material.envMapIntensity = 2;",
            "    material.needsUpdate = true;",
            "}",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        },
        {
          "disabled": true,
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "const envMapName = eventsFunctionContext.getArgument(\"envMapName\");",
            "const materialName = eventsFunctionContext.getArgument(\"materialName\");",
            "if (!scene || !materialName || !envMapName) {",
            "    return;",
            "}",
            "if (!scene.userData.shaderMaterials) {",
            "    scene.userData.shaderMaterials = {};",
            "}",
            "const material = scene.userData.shaderMaterials[materialName];",
            "if (!material) {",
            "    return;",
            "}",
            "const envMap = scene.userData.textures[envMapName];",
            "if (!envMap || !envMap instanceof THREE.CubeTexture) {",
            "    return;",
            "}",
            "material.envMap = envMap;",
            "material.envMapIntensity = 1;",
            "material.needsUpdate = true;",
            "// envMapIntensity",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "materialName",
          "name": "materialName",
          "type": "string"
        },
        {
          "description": "envMapName",
          "longDescription": "Must be envMap texture",
          "name": "mapName",
          "type": "string"
        },
        {
          "description": "intensity",
          "name": "intensity",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Map's row and column",
      "fullName": "Map's row and column",
      "functionType": "Action",
      "name": "PickMapRowColumn",
      "sentence": "Map's row and column. Material name: _PARAM1_ Picked map: _PARAM2_ Row: _PARAM3_ Column: _PARAM4_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "const materialName = eventsFunctionContext.getArgument(\"materialName\");",
            "const pickMap = eventsFunctionContext.getArgument(\"pickMap\");",
            "const pickRow = eventsFunctionContext.getArgument(\"pickRow\");",
            "const pickColumn = eventsFunctionContext.getArgument(\"pickColumn\");",
            "",
            "if (!scene || !materialName || !pickMap) {",
            "    return;",
            "}",
            "if (!scene.userData.materials) {",
            "    scene.userData.materials = {};",
            "}",
            "const material = scene.userData.materials[materialName];",
            "if (!material) {",
            "    return;",
            "}",
            "const slotUniform = material.userData.shader.uniforms.mapSlots.value;",
            "",
            "switch (pickMap) {",
            "    case 'map':",
            "        slotUniform[0] = pickRow;",
            "        slotUniform[1] = pickColumn;",
            "        break;",
            "    case 'alphaMap':",
            "        slotUniform[2] = pickRow;",
            "        slotUniform[3] = pickColumn;",
            "        break;",
            "    case 'lightMap':",
            "        slotUniform[4] = pickRow;",
            "        slotUniform[5] = pickColumn;",
            "        break;",
            "    case 'aoMap':",
            "        slotUniform[6] = pickRow;",
            "        slotUniform[7] = pickColumn;",
            "        break;",
            "    case 'bumpMap':",
            "        slotUniform[8] = pickRow;",
            "        slotUniform[9] = pickColumn;",
            "        break;",
            "    case 'normalMap':",
            "        slotUniform[10] = pickRow;",
            "        slotUniform[11] = pickColumn;",
            "        break;",
            "    case 'displacementMap':",
            "        slotUniform[12] = pickRow;",
            "        slotUniform[13] = pickColumn;",
            "        break;",
            "    case 'emissiveMap':",
            "        slotUniform[14] = pickRow;",
            "        slotUniform[15] = pickColumn;",
            "        break;",
            "    case 'metalnessMap':",
            "        slotUniform[16] = pickRow;",
            "        slotUniform[17] = pickColumn;",
            "        break;",
            "    case 'roughnessMap':",
            "        slotUniform[18] = pickRow;",
            "        slotUniform[19] = pickColumn;",
            "        break;",
            "    case 'anisotropyMap':",
            "        slotUniform[20] = pickRow;",
            "        slotUniform[21] = pickColumn;",
            "        break;",
            "    case 'clearcoatMap':",
            "        slotUniform[22] = pickRow;",
            "        slotUniform[23] = pickColumn;",
            "        break;",
            "    case 'clearcoatNormalMap':",
            "        slotUniform[24] = pickRow;",
            "        slotUniform[25] = pickColumn;",
            "        break;",
            "    case 'clearcoatRoughnessMap':",
            "        slotUniform[26] = pickRow;",
            "        slotUniform[27] = pickColumn;",
            "        break;",
            "    case 'iridescenceMap':",
            "        slotUniform[28] = pickRow;",
            "        slotUniform[29] = pickColumn;",
            "        break;",
            "    case 'iridescenceThicknessMap':",
            "        slotUniform[30] = pickRow;",
            "        slotUniform[31] = pickColumn;",
            "        break;",
            "    case 'sheenColorMap':",
            "        slotUniform[32] = pickRow;",
            "        slotUniform[33] = pickColumn;",
            "        break;",
            "    case 'sheenRoughnessMap':",
            "        slotUniform[34] = pickRow;",
            "        slotUniform[35] = pickColumn;",
            "        break;",
            "    case 'specularMap':",
            "        slotUniform[36] = pickRow;",
            "        slotUniform[37] = pickColumn;",
            "        break;",
            "    case 'specularColorMap':",
            "        slotUniform[38] = pickRow;",
            "        slotUniform[39] = pickColumn;",
            "        break;",
            "    case 'specularIntensityMap':",
            "        slotUniform[40] = pickRow;",
            "        slotUniform[41] = pickColumn;",
            "        break;",
            "    case 'transmissionMap':",
            "        slotUniform[42] = pickRow;",
            "        slotUniform[43] = pickColumn;",
            "        break;",
            "    case 'thicknessMap':",
            "        slotUniform[44] = pickRow;",
            "        slotUniform[45] = pickColumn;",
            "        break;",
            "    default:",
            "        return;",
            "}",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "materialName",
          "name": "materialName",
          "type": "string"
        },
        {
          "description": "Pick pbr map",
          "name": "pickMap",
          "supplementaryInformation": "[\"map\",\"alphaMap\",\"lightMap\",\"aoMap\",\"bumpMap\",\"normalMap\",\"displacementMap\",\"emissiveMap\",\"metalnessMap\",\"roughnessMap\",\"anisotropyMap\",\"clearcoatMap\",\"clearcoatNormalMap\",\"clearcoatRoughnessMap\",\"iridescenceMap\",\"iridescenceThicknessMap\",\"sheenColorMap\",\"sheenRoughnessMap\",\"specularMap\",\"specularColorMap\",\"specularIntensityMap\",\"transmissionMap\",\"thicknessMap\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "pickRow",
          "name": "pickRow",
          "type": "expression"
        },
        {
          "description": "pickColumn",
          "name": "pickColumn",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Pbr map loader",
      "fullName": "Pbr map loader",
      "functionType": "Action",
      "group": "Maps",
      "name": "MapLoader",
      "sentence": "Pbr map loader. Map name: _PARAM1_  mapPath: _PARAM2_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const scene = runtimeScene.getLayer().getRenderer().getThreeScene();",
            "const mapName = eventsFunctionContext.getArgument(\"mapName\") || \"map\";",
            "if (!scene) return;",
            "if (!scene.userData.textures) {",
            "    scene.userData.textures = {};",
            "}",
            "if (!scene.userData.textures[mapName]) {",
            "    scene.userData.textures[mapName] = null;",
            "}",
            "const loader = new THREE.TextureLoader();",
            "const mapPath = eventsFunctionContext.getArgument(\"mapPath\");",
            "// Load the texture",
            "loader.load(",
            "     mapPath,",
            "    (texture) => {",
            "        // Store the loaded texture in userData",
            "        scene.userData.textures[mapName] = texture;",
            "    },",
            "    (error) => {",
            "        // Extract detailed error information",
            "        let errorMessage = \"Unknown error\";",
            "        if (error.message) {",
            "            errorMessage = error.message;",
            "        } else if (error.target && error.target.error) {",
            "            errorMessage = error.target.error.message;",
            "        }",
            "        console.error(`An error occurred while loading the texture '${mapName}':`, errorMessage);",
            "    }",
            ");"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Cube texture map name",
          "name": "mapName",
          "type": "string"
        },
        {
          "description": "mapPath",
          "longDescription": "Example: \"map.jpg\". Use unique name for the file",
          "name": "mapPath",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "EnvMap texture loader",
      "fullName": "EnvMap texture loader",
      "functionType": "Action",
      "group": "Maps",
      "name": "EnvMapLoader",
      "sentence": "EnvMap texture loader. EnvMap name: _PARAM1_  pathPosX: _PARAM2_ pathNegX: _PARAM3_ pathPosY: _PARAM4_ pathNegY: _PARAM5_ pathPosZ: _PARAM6_ pathNegZ: _PARAM7_ flipY: _PARAM8_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const scene = runtimeScene.getLayer().getRenderer().getThreeScene();",
            "const mapName = eventsFunctionContext.getArgument(\"mapName\") || \"envMap\";",
            "if (!scene || !mapName) return;",
            "if (!scene.userData.textures) {",
            "    scene.userData.textures = {};",
            "}",
            "const Right = eventsFunctionContext.getArgument(\"pathPosX\");",
            "const Left = eventsFunctionContext.getArgument(\"pathNegX\");",
            "const Top = eventsFunctionContext.getArgument(\"pathPosY\");",
            "const Bottom = eventsFunctionContext.getArgument(\"pathNegY\");",
            "const Front = eventsFunctionContext.getArgument(\"pathPosZ\");",
            "const Back = eventsFunctionContext.getArgument(\"pathNegZ\");",
            "const FlipY = eventsFunctionContext.getArgument(\"flipY\");",
            "",
            "const ThreeRenderer = runtimeScene.getGame().getRenderer().getThreeRenderer();",
            "if (!ThreeRenderer) {",
            "    return;",
            "}",
            "",
            "if (!scene.userData.textures[mapName]) {",
            "    function loadTexture(path) {",
            "        if (!scene.userData.textures[path]) {",
            "            const resource = runtimeScene.getGame().getImageManager().getPIXITexture(path).baseTexture.resource;",
            "            scene.userData.textures[path] = resource.source;",
            "        }",
            "        return scene.userData.textures[path];",
            "    }",
            "    const FrontResource = loadTexture(Front);",
            "    const BackResource = loadTexture(Back);",
            "    const LeftResource = loadTexture(Left);",
            "    const RightResource = loadTexture(Right);",
            "    const TopResource = loadTexture(Top);",
            "    const BottomResource = loadTexture(Bottom);",
            "",
            "    if (FrontResource && BackResource && LeftResource && RightResource && TopResource && BottomResource) {",
            "        const CubeTexture = new THREE.CubeTexture([LeftResource, RightResource, FrontResource, BackResource, TopResource, BottomResource]);",
            "        CubeTexture.colorSpace = THREE.SRGBColorSpace;",
            "        CubeTexture.needsUpdate = true;",
            "",
            "        const pmremGenerator = new THREE.PMREMGenerator(ThreeRenderer);",
            "        pmremGenerator.compileCubemapShader();",
            "",
            "        const prefilteredCubemap = pmremGenerator.fromCubemap(CubeTexture).texture;",
            "        pmremGenerator.dispose();",
            "        scene.userData.textures[mapName] = prefilteredCubemap;     ",
            "    };",
            "};",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Cube texture map name",
          "name": "mapName",
          "type": "string"
        },
        {
          "description": "pathPosX",
          "longDescription": "Example: \"px.jpg\". Use unique name for the file",
          "name": "pathPosX",
          "type": "imageResource"
        },
        {
          "description": "pathNegX",
          "name": "pathNegX",
          "type": "imageResource"
        },
        {
          "description": "pathPosY",
          "name": "pathPosY",
          "type": "imageResource"
        },
        {
          "description": "pathNegY",
          "name": "pathNegY",
          "type": "imageResource"
        },
        {
          "description": "pathPosZ",
          "name": "pathPosZ",
          "type": "imageResource"
        },
        {
          "description": "pathNegZ",
          "name": "pathNegZ",
          "type": "imageResource"
        },
        {
          "description": "flipY",
          "name": "flipY",
          "type": "trueorfalse"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Set color space",
      "fullName": "Set color space",
      "functionType": "Action",
      "group": "Maps",
      "name": "SetColorSpace",
      "sentence": "Set color space. Map name: _PARAM1_ Color space: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const scene = runtimeScene.getLayer().getRenderer().getThreeScene();",
            "const colorSpace = eventsFunctionContext.getArgument(\"colorSpace\");",
            "const mapName = eventsFunctionContext.getArgument(\"mapName\");",
            "if (!scene || !colorSpace || !mapName || !scene.userData.textures) return;",
            "const map = scene.userData.textures[mapName]",
            "",
            "switch (colorSpace) {",
            "    case 'NoColorSpace':",
            "        map.colorSpace = THREE.NoColorSpace;",
            "        map.needsUpdate = true;",
            "        break;",
            "    case 'SRGBColorSpace':",
            "        map.colorSpace = THREE.SRGBColorSpace;",
            "        map.needsUpdate = true;",
            "        break;",
            "    case 'LinearSRGBColorSpace':",
            "        map.colorSpace = THREE.LinearSRGBColorSpace;",
            "        map.needsUpdate = true;",
            "        break;",
            "}",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Cube texture map name",
          "name": "mapName",
          "type": "string"
        },
        {
          "description": "Color space",
          "name": "colorSpace",
          "supplementaryInformation": "[\"NoColorSpace\",\"SRGBColorSpace\",\"LinearSRGBColorSpace\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Set material properties",
      "fullName": "Set material properties",
      "functionType": "Action",
      "group": "Maps",
      "name": "SetMaterialProperties",
      "sentence": "Set material properties. Material name:  _PARAM1_  Parameter: _PARAM2_ Value: _PARAM3_ Color: _PARAM4_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const scene = runtimeScene.getLayer().getRenderer().getThreeScene();",
            "const materialName = eventsFunctionContext.getArgument(\"id\");",
            "const value = eventsFunctionContext.getArgument(\"value\");",
            "const color = eventsFunctionContext.getArgument(\"color\");",
            "const pickParameter = eventsFunctionContext.getArgument(\"pickParameter\");",
            "if (!scene || !materialName) return;",
            "const rgbArray = gdjs.rgbOrHexToRGBColor(color);",
            "const hexString = '#' + gdjs.rgbToHex(rgbArray[0], rgbArray[1], rgbArray[2]);",
            "const finalColor = new THREE.Color(hexString);",
            "const material = scene.userData.materials[materialName];",
            "if (!material) {",
            "    return;",
            "};",
            "switch (pickParameter) {",
            "    case 'roughness':",
            "        material.roughness = value;",
            "        break;",
            "    case 'metalness':",
            "        material.metalness = value;",
            "        break;",
            "    case 'normalScale':",
            "        material.normalScale.set(value, value);",
            "        break;",
            "    case 'aoMapIntensity':",
            "        material.aoMapIntensity = value;",
            "        break;",
            "    case 'lightMapIntensity':",
            "        material.lightMapIntensity = value;",
            "        break;",
            "    case 'emissive':",
            "        material.emissive = finalColor;",
            "        break;",
            "    case 'emissiveIntensity':",
            "        material.emissiveIntensity = value;",
            "        break;",
            "    case 'envMapIntensity':",
            "        material.envMapIntensity = value;",
            "        break;",
            "    case 'refractionRatio':",
            "        material.refractionRatio = value;",
            "        break;",
            "    case 'displacementScale':",
            "        material.displacementScale = value;",
            "        break;",
            "    case 'displacementBias':",
            "        material.displacementBias = value;",
            "        break;",
            "    case 'fogDensity':",
            "        material.fogDensity = value;",
            "        break;",
            "    case 'reflectivity':",
            "        material.reflectivity = value;",
            "        break;",
            "    case 'ior':",
            "        material.ior = value;",
            "        break;",
            "    case 'bumpScale':",
            "        material.bumpScale = value;",
            "        break;",
            "    case 'clearcoat':",
            "        material.clearcoat = value;",
            "        break;",
            "    case 'clearcoatNormalScale':",
            "        material.clearcoatNormalScale.set(value, value);",
            "        break;",
            "    case 'clearcoatRoughness':",
            "        material.clearcoatRoughness = value;",
            "        break;",
            "    case 'iridescence':",
            "        material.iridescence = value;",
            "        break;",
            "    case 'iridescenceIOR':",
            "        material.iridescenceIOR = value;",
            "        break;",
            "    case 'iridescenceThicknessMinimum':",
            "        material.iridescenceThicknessMinimum = value;",
            "        break;",
            "    case 'iridescenceThicknessMaximum':",
            "        material.iridescenceThicknessMaximum = value;",
            "        break;",
            "    case 'sheen':",
            "        material.sheen = value;",
            "        break;",
            "    case 'sheenColor':",
            "        material.sheenColor = finalColor;",
            "        break;",
            "    case 'sheenRoughness':",
            "        material.sheenRoughness = value;",
            "        break;",
            "    case 'transmission':",
            "        material.transmission = value;",
            "        break;",
            "    case 'thickness':",
            "        material.thickness = value;",
            "        break;",
            "    case 'attenuationDistance':",
            "        material.attenuationDistance = value;",
            "        break;",
            "    case 'attenuationColor':",
            "        material.attenuationColor = finalColor;",
            "        break;",
            "    case 'specularColor':",
            "        material.specularColor = finalColor;",
            "        break;",
            "    case 'specularIntensity':",
            "        material.specularIntensity = value;",
            "        break;",
            "    case 'dispersion':",
            "        material.dispersion = value;",
            "        break;",
            "    case 'envMapIntensity':",
            "        material.envMapIntensity = value;",
            "        break;",
            "    default:",
            "        console.warn(`Unknown parameter: ${pickParameter}`); ",
            "        break;",
            "}"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Material name",
          "name": "id",
          "type": "string"
        },
        {
          "description": "pickParameter",
          "name": "pickParameter",
          "supplementaryInformation": "[\"roughness\",\"metalness\",\"normalScale\",\"aoMapIntensity\",\"lightMapIntensity\",\"envMapIntensity\",\"emissive\",\"displacementScale\",\"displacementBias\",\"clearcoat\",\"clearcoatNormalScale\",\"clearcoatRoughness\",\"bumpScale\",\"refractionRatio\",\"reflectivity\",\"ior\",\"iridescence\",\"iridescenceIOR\",\"iridescenceThicknessMinimum\",\"iridescenceThicknessMaximum\",\"sheen\",\"sheenColor\",\"sheenRoughness\",\"transmission\",\"thickness\",\"attenuationDistance\",\"attenuationColor\",\"specularColor\",\"specularIntensity\",\"dispersion\",\"emissiveIntensity\",\"envMapIntensity\",\"fogDensity\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "value",
          "longDescription": "If a parameter requires a color so use the color argument from below",
          "name": "value",
          "type": "expression"
        },
        {
          "description": "color",
          "longDescription": "Color property",
          "name": "color",
          "type": "color"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}